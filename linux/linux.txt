
1.输出流重定向
>、>>、 1>、 2>、 1>>、 2>>、 <

先看>和>>：
他们俩其实唯一的区别就是>是重定向到一个文件，>>是追加内容到文件。两个命令都是如果文件不存在则创建文件。
但是如果你重定向的是没有的文件夹里面的文件，那么文件夹他是不会帮你创建的，所以会报出错误，这点要注意。

然后是 1>、 2>、 1>>、 2>>的使用，
当我们需要把一个文件正确的输出，和错误的输出分开保存的时候就能用到他们啦。

1> right.txt 2> wrong.txt 正确的重定向到1，错误的重定向到2
那么如果我们不区分1>2>这样的重定向规则，只保存了正确的结果，错误的信息被打印到标准输出上面。

 2>&1的意思是将标准错误(2)也定向到标准输出(1)的输出文件中。
 
 Linux 中三种标准输入输出，分别是STDIN，STDOUT，STDERR，对应的数字是0，1，2。
 STDIN就是标准输入，默认从键盘读取信息；STDOUT是标准输出，默认将输出结果输出至终端，也就是显示器之类的东西；
 STDERR是标准的错误信息，默认也会显示在终端上。由于STDOUT与STDERR都会默认显示在终端上，为了区分二者的信息，就有了编号的0，1，2的定义，
 用1表示STDOUT，2表示STDERR。
 
 从command>/dev/null说起
其实这条命令是一个缩写版，对于一个重定向命令，肯定是a > b这种形式，那么command > /dev/null难道是command充当a的角色，
/dev/null充当b的角色。这样看起来比较合理，其实一条命令肯定是充当不了a，肯定是command执行产生的输出来充当a，其实就是标准输出stdout。
所以command > /dev/null相当于执行了command 1 > /dev/null。
执行command产生了标准输出stdout(用1表示)，重定向到/dev/null的设备文件中。
{
	说说2>&1
	通过上面command > /dev/null等价于command 1 > /dev/null,那么对于2>&1也就好理解了，2就是标准错误，1是标准输出，
	那么这条命令不就是相当于把标准错误重定向到标准输出么。等等是&1而不是1，这里&是什么？这里&相当于等效于标准输出。这里有点不好理解，先看下面。
	command>a 2>a 与 command>a 2>&1的区别
	通过上面的分析，对于command>a 2>&1这条命令，等价于command 1>a 2>&1可以理解为执行command产生的标准输入重定向到文件a中，标准错误也重定向到文件a中。
	那么是否就说command 1>a 2>&1等价于command 1>a 2>a呢。其实不是，command 1>a 2>&1与command 1>a 2>a还是有区别的，区别就在于前者只打开一次文件a，后者会打开文件两次，并导致stdout被stderr覆盖。&1的含义就可以理解为用标准输出的引用，引用的就是重定向标准输出产生打开的a。从IO效率上来讲，command 1>a 2>&1比command 1>a 2>a的效率更高
	再思考一下
	为什么2>&1 要放在后边呢？ 我的理解是因为2（也就是错误输出）要重定向到&1，也就是标准输出的引用中，也就是标准输出打开的文件中，所以需要现在前面打开1的输出文件。
	nohup及nohup.out
	如果使用nohup执行命令，配合&的使用，则可以不挂断的将命令执行到后台，如果没有指定重定向文件，则输出将附加到当前目录的 nohup.out 文件中。如果当前目录的 nohup.out 文件不可写，
	输出重定向到 $HOME/nohup.out 文件中，实例如下：
	nohup test.pl  2>&1 &
}

2. /dev/null 和 /dev/zero 简介及对比
/dev/null  ： 在类Unix系统中，/dev/null，或称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个EOF。
/dev/null 被称为位桶(bit bucket)或者黑洞(black hole)。空设备通常被用于丢弃不需要的输出流，或作为用于输入流的空文件。当你读它的时候，它会提供无限的空字符(NULL, ASCII NUL, 0x00)。






