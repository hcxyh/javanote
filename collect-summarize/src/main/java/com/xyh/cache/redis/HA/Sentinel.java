package com.xyh.cache.redis.HA;

/**
 * 
 * @author hcxyh  2018年8月7日
 *
 */
public class Sentinel {
	
	/**
	 一、Redis主从复制
		主从复制：主节点负责写数据，从节点负责读数据，主节点定期把数据同步到从节点保证数据的一致性
		
		1. 主从复制的相关操作
		a,配置主从复制方式一、新增redis6380.conf, 加入 slaveof 192.168.152.128 6379, 在6379启动完后再启6380，完成配置；
		b,配置主从复制方式二、redis-server --slaveof 192.168.152.128 6379 临时生效
		
		c,查看状态：info replication
		d,断开主从复制：在slave节点，执行6380:>slaveof no one
		e,断开后再变成主从复制：6380:> slaveof 192.168.152.128 6379
		f,数据较重要的节点，主从复制时使用密码验证： requirepass
		e,从节点建议用只读模式slave-read-only=yes, 若从节点修改数据，主从数据不一致 
		h,传输延迟：主从一般部署在不同机器上，复制时存在网络延时问题，redis提供repl-disable-tcp-nodelay参数决定是否关闭TCP_NODELAY,默认为关闭
		参数关闭时：无论大小都会及时发布到从节点，占带宽，适用于主从网络好的场景，
		参数启用时：主节点合并所有数据成TCP包节省带宽，默认为40毫秒发一次，取决于内核，主从的同步延迟40毫秒，适用于网络环境复杂或带宽紧张，如跨机房
		
		2. Redis主从拓扑
		a)一主一从：用于主节点故障转移从节点，当主节点的“写”命令并发高且需要持久化，可以只在从节点开启AOF（主节点不需要），
		这样即保证了数据的安全性，也避免持久化对主节点的影响 
		b)一主多从：针对“读”较多的场景，“读”由多个从节点来分担，但节点越多，主节点同步到多节点的次数也越多，影响带宽，也加重主节点的稳定
		c)树状主从：一主多从的缺点（主节点推送次数多压力大）可用些方案解决，主节点只推送一次数据到从节点B，再由从节点B推送到C，减轻主节点推送的压力。
		
		3. 主从复制原理
		
		5. 主从的缺点
			a)主从复制，若主节点出现问题，则不能提供服务，需要人工修改配置将从变主
			b)主从复制主节点的写能力单机，能力有限
			c)单机节点的存储能力也有限
			
		6.主从故障如何故障转移
			a)主节点(master)故障，从节点slave-1端执行 slaveof no one后变成新主节点；
			b)其它的节点成为新主节点的从节点，并从新节点复制数据；
			c)需要人工干预，无法实现高可用。
		
	 */
	
	/**
	 二、Redis哨兵机制（Sentinel）
		1. 为什么要有哨兵机制？
		       哨兵机制的出现是为了解决主从复制的缺点的
		2. 哨兵机制(sentinel)的高可用
		　　原理：当主节点出现故障时，由Redis Sentinel自动完成故障发现和转移，并通知应用方，实现高可用性
		其实整个过程只需要一个哨兵节点来完成，首先使用Raft算法（选举算法）实现选举机制，选出一个哨兵节点来完成转移和通知
		3. 哨兵的定时监控任务
		任务1：每个哨兵节点每10秒会向主节点和从节点发送info命令获取最拓扑结构图，哨兵配置时只要配置对主节点的监控即可，
		通过向主节点发送info，获取从节点的信息，并当有新的从节点加入时可以马上感知到
		
		任务2：每个哨兵节点每隔2秒会向redis数据节点的指定频道上发送该哨兵节点对于主节点的判断以及当前哨兵节点的信息，
		同时每个哨兵节点也会订阅该频道，来了解其它哨兵节点的信息及对主节点的判断，其实就是通过消息publish和subscribe来完成的
		
		任务3：每隔1秒每个哨兵会向主节点、从节点及其余哨兵节点发送一次ping命令做一次心跳检测，这个也是哨兵用来判断节点是否正常的重要依据
		
		客观下线：当主观下线的节点是主节点时，此时该哨兵3节点会通过指令sentinel is-masterdown-by-addr寻求其它哨兵节点对主节点的判断，
		当超过quorum（选举）个数，此时哨兵节点则认为该主节点确实有问题，这样就客观下线了，大部分哨兵节点都同意下线操作，
		也就说是客观下线
		
		4. 领导者哨兵选举流程
		a)每个在线的哨兵节点都可以成为领导者，当它确认（比如哨兵3）主节点下线时，
		会向其它哨兵发is-master-down-by-addr命令，征求判断并要求将自己设置为领导者，由领导者处理故障转移；
		b)当其它哨兵收到此命令时，可以同意或者拒绝它成为领导者；
		c)如果哨兵3发现自己在选举的票数大于等于num(sentinels)/2+1时，将成为领导者，如果没有超过，继续选举…………
		
		5. 故障转移机制
		a)由Sentinel节点定期监控发现主节点是否出现了故障
		sentinel会向master发送心跳PING来确认master是否存活，如果master在“一定时间范围”内不回应PONG 
		或者是回复了一个错误消息，那么这个sentinel会主观地(单方面地)认为这个master已经不可用了
		b) 当主节点出现故障，此时3个Sentinel节点共同选举了Sentinel3节点为领导，负载处理主节点的故障转移
		c) 由Sentinel3领导者节点执行故障转移，过程和主从复制一样，但是自动执行
		流程：
　　  		 1. 将slave-1脱离原从节点，升级主节点，
         2. 将从节点slave-2指向新的主节点
         3. 通知客户端主节点已更换
         4. 将原主节点（oldMaster）变成从节点，指向新的主节点
 		d) 故障转移后的redis sentinel的拓扑结构图
 		6. 哨兵机制－故障转移详细流程-确认主节点
		a) 过滤掉不健康的（下线或断线），没有回复过哨兵ping响应的从节点
		b) 选择salve-priority从节点优先级最高（redis.conf）的
		c) 选择复制偏移量最大，指复制最完整的从节点
	 */
	
	
	/**
	 * TODO 实战 【http://www.cnblogs.com/leeSmall/p/8398401.html】
	  以3个Sentinel节点、2个从节点、1个主节点为例进行安装部署
	  1. 前提：先搭好一主两从redis的主从复制，和之前的主从复制搭建一样，搭建方式如下：
		　　A）主节点6379节点（/usr/local/bin/conf/redis6379.conf）：
		　　　　修改 requirepass 12345678，注释掉#bind 127.0.0.1
		　　B) 从节点redis6380.conf和redis6381.conf: 配置都一样
		　　　　修改 requirepass 12345678 ,注释掉#bind 127.0.0.1,
		　　　　加上访问主节点的密码masterauth 12345678 ,加上slaveof 192.168.152.128 6379
		    注意：当主从起来后，主节点可读写，从节点只可读不可写
	  2.2. redis sentinel哨兵机制核心配置(也是3个节点)：
		       /usr/local/bin/conf/sentinel_26379.conf  
		       /usr/local/bin/conf/sentinel_26380.conf
		       /usr/local/bin/conf/sentinel_26381.conf
		将三个文件的端口改成: 26379   26380   26381
		然后：sentinel monitor mymaster 192.168.152.128 6379 2  //监听主节点6379
      		sentinel auth-pass mymaster 12345678     //连接主节点时的密码
		三个配置除端口外，其它一样。
	  
	 */
	
}
