package com.xyh.cache.redis.client;

public class Command {
	
	/**
	 	常用的命令:
	 	1.强烈建议生产环境屏蔽keys命令（后面会介绍如何屏蔽）
	 	keys命令的时间复杂度是O(N)，而且redis又是单线程执行，
	 	在执行keys时即使是时间复杂度只有O(1)例如SET或者GET这种简单命令也会堵塞，从而导致这个时间点性能抖动，
	 	甚至可能出现timeout。
	 2.scan
	 	如果把keys命令比作类似select * from users where username like '%afei%'这种SQL，
	 	那么scan应该是select * from users where id>? limit 10这种命令。
	 	SCAN cursorNumber [MATCH pattern] [COUNT count]
	 	返回结果:
	 		第一部分即1)就是下一次迭代游标，第二部分即2)就是本次迭代结果集。
	 3.slowlog
	 	get，用法：slowlog get [argument]，获取argument参数指定数量的慢日志。
		len，用法：slowlog len，总慢日志数量。
		reset，用法：slowlog reset，清空慢日志。
	 4.rename-command
	 	为了防止把问题带到生产环境，我们可以通过配置文件重命名一些危险命令，例如keys等一些高危命令。
	 	操作非常简单，只需要在conf配置文件增加如下所示配置即可：
	 		rename-command flushdb flushddbb
			rename-command flushall flushallall
			rename-command keys keysys
	5.bigkeys
		redis-cli -p 6380 --bigkeys
		-------- summary -------
		Sampled 526 keys in the keyspace!
		Total key length in bytes is 1524 (avg len 2.90)
		
		Biggest string found 'test' has 10005 bytes
		Biggest   list found 'commentlist' has 13 items
		
		524 strings with 15181 bytes (99.62% of keys, avg size 28.97)
		2 lists with 19 items (00.38% of keys, avg size 9.50)
		0 sets with 0 members (00.00% of keys, avg size 0.00)
		0 hashs with 0 fields (00.00% of keys, avg size 0.00)
		0 zsets with 0 members (00.00% of keys, avg size 0.00)
		
		最后5行可知，没有set,hash,zset几种数据结构的数据。string类型有524个，list类型有两个；
		通过Biggest ... ...可知，最大string结构的key是test，最大list结构的key是commentlist。
		
		需要注意的是，这个bigkeys得到的最大，不一定是最大。说明原因前，首先说明bigkeys的原理，非常简单，
		通过scan命令遍历，各种不同数据结构的key，分别通过不同的命令得到最大的key：
			如果是string结构，通过strlen判断；
			如果是list结构，通过llen判断；
			如果是hash结构，通过hlen判断；
			如果是set结构，通过scard判断；
			如果是sorted set结构，通过zcard判断。
		正因为这样的判断方式，虽然string结构肯定可以正确的筛选出最占用缓存，也可以说最大的key。
		但是list不一定，例如，现在有两个list类型的key，分别是：numberlist--[0,1,2]，
		stringlist--["123456789123456789"]，由于通过llen判断，所以numberlist要大于stringlist。
		而事实上stringlist更占用内存。其他三种数据结构hash，set，sorted set都会存在这个问题。
		使用bigkeys一定要注意这一点。
	
	6.monitor
		redis-cli -p 6380 monitor
		redis-cli -p 6380 monitor | grep keys
		根据输出结果找到问题.
		
	7.info
		INFO [section]
		{
			Server：运行的redis实例一些信息，包括：redis版本，操作系统信息，端口，GCC版本，配置文件路径等；
			Clients：redis客户端信息，包括：已连接客户端数量，阻塞客户端数量等；
			Memory：使用内存，峰值内存，内存碎片率，内存分配方式。这几个参数都非常重要；
			Persistence：AOF和RDB持久化信息；
			Stats：一些统计信息，最重要三个参数：OPS(instantaneous_ops_per_sec)，keyspace_hits和keyspace_misses两个参数反应缓存命中率；
			Replication：redis集群信息；
			CPU：CPU相关信息；
			Keyspace：redis中各个DB里key的信息；
		}
		
	8.config
		config是一个非常有价值的命令，主要体现在对redis的运维。因为生产环境一般是不允许随意重启的，
		不能因为需要调优一些参数就修改conf配置文件并重启。redis作者早就想到了这一点，
		通过config命令能热修改一些配置，不需要重启redis实例，可以通过如下命令查看哪些参数可以热修改
		{
			config get *  哪些参数可以修改
			config set 
			例如：config set slowlog-max-len 100，config set maxclients 1024
			这样修改的话，如果以后由于某些原因redis实例故障需要重启，那通过config热修改的参数就会被配置文件中的参数覆盖，所以我们需要通过一个命令将config热修改的参数刷到redis配置文件中持久化，通过执行如下命令即可：
			config rewrite
			执行该命令后，我们能在config文件中看到类似这种信息：
			# 如果conf中本来就有这个参数，通过执行config set，那么redis直接原地修改配置文件
			maxclients 1024
			# 如果conf中没有这个参数，通过执行config set，那么redis会追加在Generated by CONFIG REWRITE字样后面
			# Generated by CONFIG REWRITE
			save 600 60
			slowlog-max-len 100
		}
	 */
	
}
