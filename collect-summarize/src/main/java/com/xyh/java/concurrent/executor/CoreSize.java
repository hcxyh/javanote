package com.xyh.java.concurrent.executor;


/**
 * 	在项目中有个需要90W次的外围调用，使用了线程池,
 *  记录coresize的确定
 * @author xyh
 *
 */
public class CoreSize {
	
	/**
	 * 一般需要根据任务的类型来配置线程池大小：

　　如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1

　　如果是IO密集型任务，参考值可以设置为2*NCPU

　　当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。
	
	
	与CPU密集型的关系:
                一般情况下,CPU核心数 == 最大同时执行线程数.在这种情况下(设CPU核心数为n),大量客户端会发送请求到服务器,但是服务器最多只能同时执行n个线程.
                设线程池大小为m,且m>>n,则此时会导致CPU频繁切换线程来执行
                所以这种情况下,无需设置过大的线程池工作队列,(工作队列长度 = CPU核心数 || CPU核心数+1) 即可.
与I/O密集型的关系:
                1个线程对应1个方法栈,线程的生命周期与方法栈相同.
比如某个线程的方法栈对应的入站顺序为:controller()->service()->DAO(),由于DAO长时间的I/O操作,导致该线程一直处于工作队列,但它又不占用CPU,则此时有1个CPU是处于空闲状态的.(就是说CPU的性能超过I/O很多，大多数情况下都是cpu在等待I/O这样浪费CPU性能，所以设置线程数为2*NCPU)
                所以,这种情况下,应该加大线程池工作队列的长度(如果CPU调度算法使用的是FCFS,则无法切换),尽量不让CPU空闲下来,提高CPU利用率.


	-------------------------------------------------------------------------------
	线程池的理想大小取决于被提交任务的类型以及所部署系统的特性。线程池应该避免设置的过大或过小，如果线程池过大，大量的线程将在相对很少的CPU和内存资源上发生竞争，这不仅会导致更高的内存使用量，而且还可能耗尽资源。如果线程池过小，那么将导致许多空闲处理器无法执行任务，降低了系统吞吐率。

要正确设置线程池的大小，必须分析计算环境、资源预算和任务特性。包括所部署系统的CPU个数、内存大小、任务类型（计算密集、IO密集等）。如果待处理任务行为特征差异较大，那应该考虑使用多个线程池，分别处理不同类任务。大致上来说，对于计算密集型任务线程池大小和CPU个数相近通常能实现最优利用率；对于IO密集型任务，由于线程不会一直执行，所以线程吃的规模应该更大。要正确设置线程池大小，需要估算出任务的等待时间（任务从提交到结束耗时）和处理时间（实际处理耗时）的比值。

要是处理器达到期望的使用率，线程池的最优大小等于：

线程池大小=CPU个数 * CPU期望利用率 * (1 + 任务等待时间 / 任务处理时间)

假设有一个定时解析大文件并存入数据库的任务，系统部署在8核服务器上，期望定时任务执行CPU占比约20%,任务平均等待时间为150ms,任务平均处理时间为50ms
线程池最优大小=8*0.2*（1+150/50）=3
------------------------------------------------------------------------------------
	
	在《Java Concurrency in Practice》(java 并发编程实践)一书中，给出了估算线程池大小的公式：
	Nthreads=Ncpu*Ucpu*(1+w/c)，其中
	Ncpu=CPU核心数
	Ucpu=cpu使用率，0~1
	W/C=等待时间与计算时间的比率
	
	《Programming Concurrency on the JVM Mastering》即《Java 虚拟机并发编程》
	线程数=Ncpu/（1-阻塞系数）
	
	对于派系一，假设cpu100%运转，即撇开CPU使用率这个因素，线程数=Ncpu*(1+w/c)。
	现在假设将派系二的公式等于派系一公式，即Ncpu/（1-阻塞系数）=Ncpu*(1+w/c),===》阻塞系数=w/(w+c)，即阻塞系数=阻塞时间/（阻塞时间+计算时间），这个结论在派系二后续中得到应征，
	
	实际应用：
		那么实际使用中并发线程数如何设置呢？分析如下（我们以派系一公式为例）：
		
		Nthreads=Ncpu*(1+w/c)
		IO密集型：一般情况下，如果存在IO，那么肯定w/c>1（阻塞耗时一般都是计算耗时的很多倍）,但是需要考虑系统内存有限（每开启一个线程都需要内存空间），这里需要上服务器测试具体多少个线程数适合（CPU占比、线程数、总耗时、内存消耗）。如果不想去测试，保守点取1即，Nthreads=Ncpu*(1+1)=2Ncpu。这样设置一般都OK。
		计算密集型：假设没有等待w=0，则W/C=0. Nthreads=Ncpu。
		至此结论就是：
		IO密集型=2Ncpu（可以测试后自己控制大小，2Ncpu一般没问题）（常出现于线程中：数据库数据交互、文件上传下载、网络数据传输等等）
		计算密集型=Ncpu（常出现于线程中：复杂算法）
		java中：Ncpu=Runtime.getRuntime().availableProcessors()
		
	即对于计算密集型的任务，在拥有N个处理器的系统上，当线程池的大小为N+1时，通常能实现最优的效率。(即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费。)
	即，计算密集型=Ncpu+1，但是这种做法导致的多一个cpu上下文切换是否值得，这里不考虑。读者可自己考量。
		
----------------------------------------------------------------------------------------------
	
	线程池中线程的数目是跟线程池所要处理的任务性质有关的

	任务的性质：CPU密集型任务、IO密集型任务、混合型任务。
	任务的优先级：高、中、低。
	任务的执行时间：长、中、短。
	任务的依赖性：是否依赖其他系统资源，如数据库连接等。
	性质不同的任务可以交给不同规模的线程池执行。
	
	针对不同的任务性质而言：CPU密集型任务应配置尽可能小的线程，如配置CPU个数+1的线程数，IO密集型任务应配置尽可能多的线程，因为IO操作不占用CPU，不要让CPU闲下来，应加大线程数量，如配置两倍CPU个数+1，而对于混合型的任务，如果可以拆分，拆分成IO密集型和CPU密集型分别处理，前提是两者运行的时间是差不多的，如果处理时间相差很大，则没必要拆分了。
	
	任务对其他系统资源有依赖：如某个任务依赖数据库的连接返回的结果，这时候等待的时间越长，则CPU空闲的时间越长，那么线程数量应设置得越大，才能更好的利用CPU。 
	
	线程等待时间所占比例越高，这样的话CPU空闲时间比较多，为了能够更好的利用CPU，需要较多线程。
	
	如果线程CPU时间所占比例越高，说明CPU比较繁忙，此时需要越少线程。 
	
	另外，如果线程数量过多，线程之间的切换也会带来开销。



	是否使用线程池就一定比使用单线程高效呢？
	答案是否定的，比如Redis就是单线程的，但它却非常高效，基本操作都能达到十万量级/s。从线程这个角度来看，部分原因在于：多线程带来线程上下文切换开销，单线程就没有这种开销。
	
	
	 */
	
	
}
