/**
 * 
 * 
 * @author hcxyh 2018年8月11日
 *
 */
package com.xyh.java.concurrent.cas;

/**
 * TODO 继承BlockingQueue
 * 
 * 如果实现一个线程安全的队列有两种实现方式一种是使用阻塞算法， 另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁
 * （入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现，
 * 
 * 而非阻塞的实现方式则可以使用循环CAS的方式来实现 采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，
 * 当我们获取一个元素时，它会返回队列头部的元素.
 * 
 * CAS存在一个很明显的问题，即ABA问题。 问题：如果变量V初次读取的时候是A，并且在准备赋值的时候检查到它仍然是A，
 * 那能说明它的值没有被其他线程修改过了吗？
 * 
 * 如果在这段期间曾经被改成B，然后又改回A，那CAS操作就会误认为它从来没有被修改过。
 * 针对这种情况，java并发包中提供了一个带有标记的原子引用类AtomicStampedReference，
 * 它可以通过控制变量值的版本来保证CAS的正确性。
 * 
 * 当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，
 * 而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。
 * 
 * CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。
 * 否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。 （在 CAS 的一些特殊情况下将仅返回 CAS
 * 是否成功，而不提取当前值。） CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；
 * 否则，不要更改该位置，只告诉我这个位置现在的值即可。” 这其实和乐观锁的冲突检查+数据更新的原理是一样的。
 * 
 * 
 * CAS 是通过 Unsafe 类来实现的，Unsafe 提供了硬件级别的原子操作， 关于 CAS 的方法主要是 native 的
 * compareAndSwapObject、compareAndSwapInt、
 * compareAndSwapLong，其比较交换是一组原子操作，因为是硬件级别的操作，所以效率会高一些。
 * 
 */
