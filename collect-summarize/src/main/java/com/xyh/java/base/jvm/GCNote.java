package com.xyh.java.base.jvm;


/**
 * 
 * @author hcxyh  2018年8月11日
 *
 */
public class GCNote {
	/**
	 * Java语言中一个显著的特点就是引入了垃圾回收机制，这个大家都清楚，垃圾回收的概念这里也不做介绍，重点是垃圾回收是在什么时候开始？对什么东西，做了什么事情？
			GC何时开始：
				所有的回收器类型都是基于分代技术来实现的，那就必须要清楚对象按其生命周期是如何划分的。
				
			年轻代：划分为三个区域：原始区(Eden)和两个小的存活区(Survivor)，两个存活区按功能分为From和To。
			绝大多数的对象都在原始区分配，超过一个垃圾回收操作仍然存活的对象放到存活区。垃圾回收绝大部分发生在年轻代。
			年老代：存储年轻代中经过多个回收周期仍然存活的对象，对于一些大的内存分配，也可能直接分配到永久代。
			持久代：存储类、方法以及它们的描述信息，这里基本不产生垃圾回收。
			
			有了以上这些铺垫之后开始回答GC何时开始：
			Eden内存满了之后，开始Minor GC（从年轻代空间回收内存被称为 Minor GC）；
			升到老年代的对象所需空间大于老年代剩余空间时开始Full GC（但也可能小于剩余空间时，被HandlePromotionFailure参数强制Full GC）
			
			对什么东西操作，即垃圾回收的对象是什么：
				从root开始搜索没有可达对象，而且经过第一次标记、清理后，仍然没有复活的对象。 
			
			做了什么东西：
				主要做了清理对象，整理内存的工作。具体的引申如下
			
			垃圾回收器的类型：
			串行垃圾回收器（Serial Garbage Collector）
			并行垃圾回收器（Parallel Garbage Collector）
			并发标记扫描垃圾回收器（CMS Garbage Collector）
			G1垃圾回收器（G1 Garbage Collector）
			
			垃圾回收算法：
				引用计数法
				标记清除法
				复制算法
				标记压缩算法
				分代算法
				分区算法
	 */
	
	/**
	 * 这个算法的实现是，给对象中添加一个引用计数器，每当一个地方引用这个对象时，
	 * 计数器值+1；当引用失效时，计数器值-1。任何时刻计数值为0的对象就是不可能再被使用的。
	 * 这种算法使用场景很多，但是，Java中却没有使用这种算法，因为这种算法很难解决对象之间相互引用的情况。看一段代码：
	 */
	/**
	 * 虚拟机参数：-verbose:gc
	 */
	public static class ReferenceCountingGC
	{
	    private Object instance = null;
	    private static final int _1MB = 1024 * 1024;
	 
	    /** 这个成员属性唯一的作用就是占用一点内存 */
	    private byte[] bigSize = new byte[2 * _1MB];
	 
	    public static void main(String[] args)
	    {
	        ReferenceCountingGC objectA = new ReferenceCountingGC();
	        ReferenceCountingGC objectB = new ReferenceCountingGC();
	        objectA.instance = objectB;
	        objectB.instance = objectA;
	        objectA = null;
	        objectB = null;
	 
	        System.gc();
	        /**
	         	[GC 4417K->288K(61440K), 0.0013498 secs]
				[Full GC 288K->194K(61440K), 0.0094790 secs]
				看到，两个对象相互引用着，但是虚拟机还是把这两个对象回收掉了，这也说明虚拟机并不是通过引用计数法来判定对象是否存活的。
	         */
	    }
	}
	
	/**
	 * FIXME
	 * https://mp.weixin.qq.com/s/bHrqihRj25sIg8YGWvIvmw
	 2、可达性分析法
		这个算法的基本思想是通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链（即GC Roots到对象不可达）时，则证明此对象是不可用的。在Java语言中可以作为GC Roots的对象包括：
		虚拟机栈中引用的对象
		方法区中静态属性引用的对象
		方法区中常量引用的对象
		本地方法栈中JNI（即Native方法）引用的对象
		4种引用状态
		在JDK1.2之前，Java中引用的定义很传统：如果引用类型的数据中存储的数值代表的是另一块内存的起始地址，
		就称这块内存代表着一个引用。这种定义很纯粹，但是太过于狭隘，一个对象只有被引用或者没被引用两种状态。
		我们希望描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是非常紧张，
		则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。
		在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用4种，这4种引用强度依次减弱。
		1、强引用
		代码中普遍存在的类似”Object obj = new Object()”这类的引用，只要强引用还存在，
		2、软引用
		描述有些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收。
		如果这次回收还没有足够的内存，才会抛出内存溢出异常。Java中的类SoftReference表示软引用
		3、弱引用
		描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，
		都会回收掉只被弱引用关联的对象。Java中的类WeakReference表示弱引用
		4、虚引用
		这个引用存在的唯一目的就是在这个对象被收集器回收时收到一个系统通知，被虚引用关联的对象，
		和其生存时间完全没关系。Java中的类PhantomReference表示虚引用
		
		方法区回收
		虚拟机规范中不要求方法区一定要实现垃圾回收，而且方法区中进行垃圾回收的效率也确实比较低，
		但是HotSpot对方法区也是进行回收的，主要回收的是废弃常量和无用的类两部分。
		判断一个常量是否“废弃常量”比较简单，只要当前系统中没有任何一处引用该常量就好了，
		但是要判定一个类是否“无用的类”条件就要苛刻很多，类需要同时满足以下三个条件：
		该类所有实例都已经被回收，也就是说Java堆中不存在该类的任何实例
		加载该类的ClassLoader已经被回收
		该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
		在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载功能，以保证方法区不会溢出。
	 	
	 */
	
}
