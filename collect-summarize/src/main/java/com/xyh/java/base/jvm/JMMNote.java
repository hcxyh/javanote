package com.xyh.java.base.jvm;

/**
 * jmm图(对比理解线程安全)
 * @author hcxyh  2018年8月11日
 *
 */
public class JMMNote {
	
	
	/**
	 * TODO
	 * JMM规定了线程的工作内存和主内存的交互关系，以及线程之间的可见性和程序的执行顺序。
	 * JMM对程序员屏蔽了CPU以及OS内存的使用问题，能够使程序在不同的CPU和OS内存上都能够达到预期的效果。
	   Java采用内存共享的模式来实现线程之间的通信。编译器和处理器可以对程序进行重排序优化处理，但是需要遵守一些规则，不能随意重排序。
	   		1.原子性：一个操作或者多个操作要么全部执行要么全部不执行；
			2.可见性：当多个线程同时访问一个共享变量时，如果其中某个线程更改了该共享变量，其他线程应该可以立刻看到这个改变；
			3.有序性：程序的执行要按照代码的先后顺序执行；
	   JMM对原子性并没有提供确切的解决方案，但是JMM解决了可见性和有序性，至于原子性则需要通过锁或者Synchronized来解决了。
	   happens-before原则是JMM中非常重要的一个原则，它是判断数据是否存在竞争、线程是否安全的主要依据。
	         依靠这个原则，我们可以解决在并发环境下两个操作之间是否存在冲突的所有问题。
	   JMM规定，两个操作存在happens-before关系并不一定要A操作先于B操作执行，只要A操作的结果对B操作可见即可。
	   
	   在程序运行过程中，为了执行的效率，编译器和处理器是可以对程序进行一定的重排序，但是他们必须要满足两个条件：
	   1 执行的结果保持不变，
	   2 存在数据依赖的不能重排序。重排序是引起多线程不安全的一个重要因素。
	   
	 */

}
