package com.xyh.reactor;

public class FunctionProgremNote {


    /**
     * 简单梳理下 编程范式 以及同步异步 和 设计模式的关系
     * 1.编程范式
     *      oop (对数据的抽象 )  将数据抽象为一个对象,封装,继承,多态.
     *          异步可以通过多线程方式实现,
     *              或者使用发布订阅实现异步.
     *      fp (对行为的抽象),
     *          函数是第一公民,并且函数内部都是不可变变量,不存在线程安全问题.
     *
     *      rxJava等响应式编程框架,
     *          是基于事件的发布订阅设计模式的异步。
     *
     *  2.发布订阅 和 观察者模式的区别和联系
     *      场景:用户登录操作之后,在req请求主线程判断密码校验通过,则发布登录事件,
     *      订阅登录事件的各个子业务系统进行后续处理.(发券,添加积分)
     *
     *      nio,netty,也是使用基于事件的发布订阅的模式来实现异步.
     *      Netty的所有IO操作都是异步非阻塞的，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。
     *
     *
     */

    /*
    什么是函数式编程？在维基百科中给出了详细的定义，函数式编程（英语：functional programming）或称函数程序设计，又称泛函编程，是一种编程范型，
    它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。
    函数编程语言最重要的基础是λ演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。
    而在面向对象编程中，面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程范型，同时也是一种程序开发的方法。
    它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，
    对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。

    对象与对象之间的关系是面向对象编程首要考虑的问题，而在函数式编程中，所有的数据都是不可变的，
    不同的函数之间通过数据流来交换信息，函数作为FP中的一等公民，享有跟数据一样的地位，可以作为参数传递给下一个函数，同时也可以作为返回值。

    面向对象编程的优点
            面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反。
            传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。
            面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，
            因此它们都可以被看作一个小型的“机器”，即对象。
            目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。
            此外，支持者声称面向对象程序设计要比以往的做法更加便于学习，因为它能够让人们更简单地设计并维护程序，
            使得程序更加便于分析、设计、理解。同时它也是易拓展的，
            由于继承、封装、多态的特性，自然设计出高内聚、低耦合的系统结构，使得系统更灵活、更容易扩展，而且成本较低。
            在面向对象编程的基础上发展出来的23种设计模式广泛应用于现今的软件工程中，极大方便了代码的书写与维护。
                创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
                结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
                行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
    面向对象编程的缺点
            面向对象编程以数据为核心，所以在多线程并发编程中，多个线程同时操作数据的时候可能会导致数据修改的不确定性。
            在现在的软件工程中，由于面向对象编程的滥用，导致了很多问题。首先就是为了写可重用的代码而产生了很多无用的代码，导致代码膨胀，
            同时很多人并没有完全理解面向对象思想，为了面向对象而面向对象，使得最终的代码晦涩难懂，给后期的维护带来了很大的问题。
            所以对于大项目的开发，使用面向对象会出现一些不适应的情况。
            面向对象虽然开发效率高但是代码的运行效率比起面向过程要低很多，这也限制了面向对象的使用场景不能包括那些对性能要求很苛刻的地方。

    函数式编程的优点
            在函数式编程中，由于数据全部都是不可变的，所以没有并发编程的问题，是多线程安全的。
            可以有效降低程序运行中所产生的副作用，对于快速迭代的项目来说，
            函数式编程可以实现函数与函数之间的热切换而不用担心数据的问题，因为它是以函数作为最小单位的，
            只要函数与函数之间的关系正确即可保证结果的正确性。
            函数式编程的表达方式更加符合人类日常生活中的语法，代码可读性更强。实现同样的功能函数式编程所需要的代码比面向对象编程要少很多，
            代码更加简洁明晰。函数式编程广泛运用于科学研究中，因为在科研中对于代码的工程化要求比较低，写起来更加简单，
            所以使用函数式编程开发的速度比用面向对象要高很多，
            如果是对开发速度要求较高但是对运行资源要求较低同时对速度要求较低的场景下使用函数式会更加高效。

    函数式编程的缺点
            由于所有的数据都是不可变的，所以所有的变量在程序运行期间都是一直存在的，非常占用运行资源。
            同时由于函数式的先天性设计导致性能一直不够。虽然现代的函数式编程语言使用了很多技巧比如惰性计算等来优化运行速度，
            但是始终无法与面向对象的程序相比，当然面向对象程序的速度也不够快。
            函数式编程虽然已经诞生了很多年，但是至今为止在工程上想要大规模使用函数式编程仍然有很多待解决的问题，
            尤其是对于规模比较大的工程而言。如果对函数式编程的理解不够深刻就会导致跟面相对象一样晦涩难懂的局面。

    总结
            函数式编程和面向对象编程各有利弊，一个语法更加自由，一个健壮性更好。
            作为程序员应该对两种编程方式都有所了解，不管是哪种方式，只要能够很好的解决当前的问题就是正确的方式，
            毕竟对于软件工程来说解决问题是最主要的，用的工具反而没有那么重要，就像对程序员来说语言不重要，
            重要的是解决问题的思想。

    现在这两者的发展趋势是相互借鉴的，许多以面向对象作为基础的语言例如Java等都在新的版本中添加了对函数式编程的支持，
    而函数式编程则借鉴了一些在面向对象语言里用的一些编译技巧使得程序运行更快。


     */


    /*
    大家应该都知道面向对象的特性（抽象、封装、继承、多态）。其实在Java8出现之前，我们关注的往往是某一类对象应该具有什么样的属性，
    当然这也是面向对象的核心--对数据进行抽象。但是java8出现以后，这一点开始出现变化，似乎在某种场景下，
    更加关注某一类共有的行为（这似乎与之前的接口有些类似），这也就是java8提出函数式编程的目的。

    2.2 不可变对象的优点
        2.2.1 对并发友好
        提到多线程并发，最让人苦恼的莫过于线程间共享资源的访问冲突，古往今来，多少Bug因此而生。即便是最有经验的程序员，
        面对多线程编程时，也往往需瞻前顾后，反复思量后，才能逐渐对自己编写的代码产生信心。
        如果多线程错误可以跟编译错误一样，能够被自动发现该有多好。
    目前大多数语言中，面对多线程冲突问题，都是采用序列化访问共享资源的方案。Java也不例外，Java语言中的synchronize关键字，
    Lock锁对象等机制，都是为实施此类方案准备的。此类方案最大的弊端在于：
    能不能保证多线程间没有冲突，完全取决于程序员对共享资源加锁解锁的时机对不对。如果程序员加锁的时机有丝毫差错，
    Java是不负责检测的，可能你的单元测试、集成测试、预发布测试也发现不了，程序上线后也看上去一切正常，但是等到某一个重要的时刻，
    它会以一个突如其来的线上Bug的形式通知你，是不是欲哭无泪。
    然而，解决多线程冲突问题还有一个方向，就是从多线程冲突的根因 —— 共享资源上入手。
    如果完全没有共享资源，多线程冲突问题就天然不存在了，比如Java中的ThreadLocal机制就是利用了这一点理念。
    但是大多数时候，线程间是需要使用共享资源互通信息的。此时，如果该共享资源诞生之后就完全不再变更（犹如一个常量），
    多线程间共同并发读取该共享资源是不会产生线程冲突的，因为所有线程无论何时读取该共享资源，总是能获取到一致的、完整的资源状态，
    这样也能规避多线程冲突。不可变对象就是这样一种诞生之后就完全不再变更的对象，该类对象可以天生支持无忧无虑地在多线程间共享。
    如果线程间对共享资源的访问不仅局限于读，还想改变共享资源的状态呢，这种时候不可变对象又能否从容应对呢？
    答案是肯定的。原理很简单，某个线程想要修改共享资源A的状态时，不要去直接修改A本身的状态，
    而是先在本线程中构造一个新状态的共享资源B，待B构造完整后，再用B去直接替换A，由于对引用赋值操作是原子性的，
    所以也不会造成线程冲突问题。不可变对象所提供的方法，不会改变自身的状态，最多构造一个新状态的新对象的返回，
    这也与上述思路完全契合。但是需要注意可见性问题，如果你想要A替换B后，其他所有线程实时感知到此变化，
    需要使用volatile关键字保证可见性。

     */


}
